#!/usr/bin/env python3

import numpy as np
import math
import os

# Output Files
if os.path.exists("message_flip.txt"):
	os.remove("message_flip.txt")
if os.path.exists("error_flip.txt"):
	os.remove("error_flip.txt")
if os.path.exists("error_hash.txt"):
	os.remove("error_hash.txt")
if os.path.exists("sk_flip.txt"):
	os.remove("sk_flip.txt")
if os.path.exists("g_flip.txt"):
	os.remove("g_flip.txt")
	
R_BITS = 10163
BLOCK_SIZE = 32
T1 = 134
W = 142

PRINT_C = 1

BLOCKS = np.ceil(R_BITS/BLOCK_SIZE).astype(int)

def flip_bytes_in_block(block):
    b1 = block & 0xFF
    b2 = (block >>  8) & 0xFF
    b3 = (block >> 16) & 0xFF
    b4 = (block >> 24) & 0xFF
    b1_flipped = int('{:08b}'.format(b1, width=8)[::-1], 2)
    b2_flipped = int('{:08b}'.format(b2, width=8)[::-1], 2)
    b3_flipped = int('{:08b}'.format(b3, width=8)[::-1], 2)
    b4_flipped = int('{:08b}'.format(b4, width=8)[::-1], 2)
    
    return (b4_flipped << 24) + (b3_flipped << 16) + (b2_flipped << 8) + b1_flipped


# extract_words_msb: extracts the words (32 bit) from a given stream s and returns them in an array
def extract_words_msb(s):
  blocks_out = np.zeros(318).astype(int)
  intermediate = 0
  
  for b in range(0, BLOCKS):
    current_block = flip_bytes_in_block( (s >> (10176-(b+1)*BLOCK_SIZE)) & 0xFFFFFFFF)
    temp = (intermediate << 19) + (current_block >> 13)
    intermediate = current_block & (2**13-1)
    current_block = temp
    blocks_out[b] = current_block
    
  return blocks_out
    
def extract_words_msb_without_flip(s):
  blocks_out = np.zeros(318).astype(int)
  intermediate = 0
  
  for b in range(0, BLOCKS):
    current_block = ( (s >> (10176-(b+1)*BLOCK_SIZE)) & 0xFFFFFFFF)
    temp = (intermediate << 19) + (current_block >> 13)
    intermediate = current_block & (2**13-1)
    current_block = temp
    blocks_out[b] = current_block
    
  return blocks_out

def print_ram_content(blocks, mode):
  line = ''
  
  if mode == "FAST":
    print("-- upper part -------------")
    line = '",'
    for b in range(0, int(BLOCKS/2)):
      current_block = blocks[BLOCKS-1-b*2]
      current_block_hex = hex(current_block).split('x')[-1].zfill(8) 
      if np.mod(b+1, 8) == 0:
        line = 'INIT_' + hex(np.floor(b/8).astype(int)+64).split('x')[-1].zfill(2) + ' => X"' + current_block_hex + line
        print(line)
        line = '",'
      else:
        line = current_block_hex + line
    line = 'INIT_' + hex(np.floor(b/8).astype(int)+64).split('x')[-1].zfill(2) + ' => X"' + hex(np.floor(0).astype(int)).split('x')[-1].zfill(8) + line
    print(line)
    
    print("-- lower part -------------")
    line = '",'
    for b in range(0, int(BLOCKS/2)):
      current_block = blocks[BLOCKS-1-b*2-1]
      current_block_hex = hex(current_block).split('x')[-1].zfill(8) 
      if np.mod(b+1, 8) == 0:
        line = 'INIT_' + hex(np.floor(b/8).astype(int)).split('x')[-1].zfill(2) + ' => X"' + current_block_hex + line
        print(line)
        line = '",'
      else:
        line = current_block_hex + line
    line = 'INIT_' + hex(np.floor(b/8).astype(int)).split('x')[-1].zfill(2) + ' => X"' + hex(np.floor(0).astype(int)).split('x')[-1].zfill(8) + line
    print(line)
  
  else:
    for b in range(0, BLOCKS):
      current_block = blocks[BLOCKS-1-b]
      current_block_hex = hex(current_block).split('x')[-1].zfill(8)
      if np.mod(b+1, 8) == 0:
        line = 'INIT_' + hex(np.floor(b/8).astype(int)).split('x')[-1].zfill(2) + ' => X"' + current_block_hex + line
        print(line)
        line = '",'
      else:
        line = current_block_hex + line
    print(line)
    
# ===========================================================
#
# MESSAGE 
#
# ===========================================================
m=0x919FA4CF9C798DA8B55CE1BEA2EA475D53872DF68F0CE855B4CBCA3C5529CDCDBE3C6CE86017B1A057898A76A6C3D8A6BB85868FAA306749D4C2892064800180F34D70A46BA7661C2091C6830A3CC930D1E8F7AA4AC5FDB3B330B62E5B9BC69E374AD182E7F62111E12C8FC3B1C1FFA50B85B712B19192771841183209A880305CAAE5EE91386174B8C0D2D87123E34232AD003D27F96BDC8F769A03728711B7DDE1C28C24B8C68C080969CDA832C0D7DACD292E57CECF602A7BD68117CFD09FF8C757F820E8984DE7F50D08A7EA2CC01E2014A6847F9EFE5904B47D761DCD6F2A79A01A21094F4CB190AEB2F8E8E4CED6725A8CA04FA62A3D5A1C892A1E59B4C42ECF6A8328A78B44D32ACE71ED02C00208C8254DAEF0892793C825D63BA2D35183D1FA58735734288C8D7B77BF3C68A1E14D0ED34A619E1F88D2A0E8603D9A02ED5E14F8EA3DB83C97AA3653E52BF34E87AA75F4B1331A0514946550537DCB93152D8A2B39F78BD610DE898C8EFFF616BCD1DE9D56EE4F15A6D6477D6B947EDA0427CA3BB857985C0426DB087F3D396596636D0E4F75700285A0E09C12BF573C436592CCAAAA62AF62D91B424D7F83B1B48F14573AE7D53B957BB1EE74718C318D0198DDBA68C25662C5F22D9FCC6DDE0F088A9DDA57D91903B51E2E53F81E73916517BC1A1068274060B7E460B32BA81FDD12410E5F6ED726D79AFAD03BE47E21EB7CA56A54DEE53B84F0096731EC7E635B2D35245BC75EF4EB1B7E48EE67BACD736A6755BDD4A958C4CD6866EB8989B1DA62FA24EC9B758C8E3758FFD562BE9C796379E13B360DBA50B189381246A93FA61A5EEA0C5AA94FCB721DEEA12CDAEE5859C034BEE014A8EAC92CE30498D96770193541E2EF3A50B594425AC7DE45BA70CCA61E869236A9A2BD1D2B41B3900C90A88C6A78545D0147401A67EF357E2B03BC1A4B51CEDC24A245B055B3C447446BAC7894EAFE59373B008CC5CB7A042C85E6D65DCF8C1FB6C74BE944332BA1E1108CB5F5BA318B49ADF7BABB3BABA62C41DD5B960444DB81A33F3204DBEAA48895945038B1E4B66DD63E432EAAB9E6F04330E2CC5C70AF37BF8934D35FE7477CDE1241E728E69F67CDED89D6AB0D1AD46FD6D0C1ABD1CDDE7B26BB461FA8EABB9973B72FD86108BF732E701D10C7B72984FD01C0C0F029127C56040AA2AF2835818D370604C53B512C42DB5D8D61CC4AD6F741F1DF8D968846A4D3E624FEE41BB5E40B57FCAF375DFC222EAE4EC4AD0E15631DCD0D5D1F2556AE4D1699D3B32948D5BDAACCE22F4FB218CD44C947583F31E30BA86184BDCE4173578E306D55442DEC2A9D5A5DF64D5CA9F0D472D5483ED7D5B73C5417923CC3B3FA3EFA0877B79D95DB1771DC5AB4A12A0AB5B38D5D7CB18134C2ADA5EC1C3E8C6BDB51310AB2942ADDCB5E4986919FAA8B45E51A5913832D5AF3F54D0133D5ECBCFD1471D1133081088B74567D543B5AC8E47EAEF9D7B969EB444677292D2A9DD8755112858C872938BB6013BC6D3469BC63E9F4D38ABEDD87AACDA36A3655B1EF88AF5A7B3FED36776CB65D240D810EE5E99E1E1669E27F4854F7767D59A8E649D7759C6451388D1A3E0DDADE1A3D07630C743B8CC49C3FC3F4B5E99584CC8D4283B83079A93BBB1904252345EB4AE91EDCD76B097F6BFA2B40A7BD68182ABE5F42BF2D6C6FF8DC5A0740E858F846C445FEF0A23F452B588E01AAB2DB5569B71FD3F562BCC35E5413A4875BEAFBE4A1A5F5E433683126D247EA759EDB524D8C4072C788E0FFBE121B460300 #added 8 extra bits

blocks_out = np.zeros(BLOCKS).astype(int)

for b in range(0, BLOCKS):
  current_block = flip_bytes_in_block( (m >> (10176-(b+1)*BLOCK_SIZE)) & 0xFFFFFFFF )
  current_block_flipped = int('{:032b}'.format(current_block, width=32)[::-1], 2)
  blocks_out[b] = current_block_flipped

with open('message_flip.txt', 'a') as f:
  for item in blocks_out:
    item_hex = hex(item).split('x')[-1].zfill(8)
    f.write("%s%s%s%s%s%s%s%s\n" % (item_hex[0], item_hex[1], item_hex[2], item_hex[3], item_hex[4], item_hex[5], item_hex[6], item_hex[7]))
f.close()



# ===========================================================
#
# ERROR 
#
# ===========================================================


e0=0x000000000000000000000020000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000006000080000000000000000000000000000000000800000000000000200000000000000000000000000000000400000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000001000000000000000000020000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000001000000000200000000000000000000000000000000400000000000000000000000800000000000000000000000000100000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000004000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000100000000000000000000000000000000020000000000000000000002000000000000000000000000000000000000001000000000000000000000000000000088000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000008020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000001000000000100000000000000000000000800000000000000000020000000000000000000000000000000000000000000000010000000008000000000000000000800000000000000000000000000000000000000000000000000004000000000000008000000000000000000000000000000400000000000000042000000000000000000000000000000000000000000000000000000000000004000000000000000010000000000000800000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000008000000000000000000000000000000000400000000000000000000000400002000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000


e1=0x00010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000020000100001000000000400000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000100000000000000000000000000000010000000000000400000000000000000000000000000000000000008000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000040000000000000000000080040000000000000000000000000000000000000000000000000000000000000000000080000000080000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010100000000000000000000000000000000000000000400000000000000000000000000000000000000000000010000000000000000000000000000000200000000000000000000000000000000000001000002000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000010000000000200000000002100020000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000A040000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000400000000000000000000000000040000400000000000000000000000000000000000000000000080000000000000000000000000000000000001000000000000000000000000000000008000000000000000000000000000000100000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000800000100000000010000000000000020000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800008000000000000000000000000400000000000000000000000000000000000000008000008000000000000000000000000000000000000000000000004000000000100000000000000000000000010000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000001000000000004000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000020000000000000000000000000000000000000


n=0
blocks_out_e = np.zeros(T1).astype(int)
intermediate = 0
line = ''
error_output = ''
line2 = ''

print("e0 hex")
for b in range(0, BLOCKS):
  current_block = flip_bytes_in_block( (e0 >> (10176-(b+1)*BLOCK_SIZE)) & 0xFFFFFFFF)
  
  # Required for generate output to validate the hash
  line = line + bin(current_block).split('b')[-1].zfill(32)
  if np.mod(b+1, 26) == 0:
    with open('error_hash.txt', 'a') as f:
      for i in range(0, 832):
        f.write("%s" % (line[i]))
      f.write("\n")
    f.close()
    line = ''

  temp = (intermediate << 19) + (current_block >> 13)
  intermediate = current_block & (2**13-1)
  current_block = temp
  #print(hex(current_block).split('x')[-1].zfill(8))
  if current_block != 0:
    address = BLOCKS-1-b
    
    for i in range(0, 32):
      if (current_block & (1 << i)) != 0:
        bit = np.log((1 << i))/np.log(2)
        rand_out = (address << 5) + bit.astype(int)
        blocks_out_e[n] = rand_out
        n = n + 1

# Last row
with open('error_hash.txt', 'a') as f:
  for i in range(0, 179):
    f.write("%s" % (line[i]))
  f.write("\n")
f.close()


line = ''
# e1
intermediate = 0
for b in range(0, BLOCKS):
  current_block = flip_bytes_in_block( (e1 >> (10176-(b+1)*BLOCK_SIZE)) & 0xFFFFFFFF)
  
  # Required for generate output to validate the hash
  line = line + bin(current_block).split('b')[-1].zfill(32)
  if np.mod(b+1, 26) == 0:
    with open('error_hash.txt', 'a') as f:
      for i in range(0, 832):
        f.write("%s" % (line[i]))
      f.write("\n")
    f.close()
    line = ''
    
  temp = (intermediate << 19) + (current_block >> 13)
  intermediate = current_block & (2**13-1)
  current_block = temp
  if current_block != 0:
    address = BLOCKS-1-b
    
    for i in range(0, 32):
      if (current_block & (1 << i)) != 0:
        bit = np.log((1 << i))/np.log(2)
        rand_out = (1 << 14) + (address << 5) + bit.astype(int)
        blocks_out_e[n] = rand_out
        n = n + 1  


# Last row of hash output
with open('error_hash.txt', 'a') as f:
  for i in range(0, 179):
    f.write("%s" % (line[i]))
  f.write("\n")
f.close()  

with open('error_flip.txt', 'a') as f:
  for item in blocks_out_e:
    item_bin = bin(item).split('b')[-1].zfill(15)
    for i in range(0,15):
      f.write("%s" % item_bin[i])
    f.write("\n")
f.close()


pk0=0x2C4E054A9AC5B4EB0DD77C968CB112F0FAA6C0A57FAF13690E42EE96A11E0A89AAE64E3E467D51A817839A342B5EABEFA0CCA3D8BC90562B2B980643113154E49810954CB1D5894AFB89A6AC077D6B00768B0B0E30A07A463E2DF8D0250864334BE4C3E236957BCE2026027279CC1D098A58278DB7B8076F4A3B1C2126F845965439102A3B54668CDBDC58DC635F86D5D8827CB63B4E4DC65021C4A60B5F133CF8789CB195A38A48A7B4A6B12BB888855D40641CE1C20F79757219E5000E3987776EA7DF683D638869A2C6D2650F3A056A41B2DB5896D2317B7A16C61E9B01C6F81B273138489489B419AE99011D11AF749CCF7E13B9C87EB839E51C9D644BFE5648BA8A2C300CA9F47F4911738E4A1B1B4E0D07C04D79C9E8A49C317BF0BA2C5688726FE523611F1AA7C659AC7A67C5FA81E8F9E59ABE5A31C3736235A46B4B84C78063B7D889E73C1B3B11D8ED020A89978FB400A4BF7D89B440ABC0C8D750222640215FBADD27BC7F935990EE49F81E720328A3A7B0A3B11D1533DDEAD9A17554D6D4A190E1BCD43CAD317B87AE79F66F6493EB76CA011A4E03F29B4107F648878A2C2A5E8EDDC3A6CEE36CFF85AE3BC7CB1C8D91C469BAA4D8356C42444E8E9A8113D8833EC7736407EFE9FB01E124228C3A8A9963477BFCE26BFD9F33A11AC640CA7AADA0A609D713EE596112E3E4897C149E4C1A8F902EB00839F34A64C99886582293B955F9D8A7A66E03B2D2CB0FA6C10E1631365CE585B726A88DB981C9A3161F174EF5CD19FDBFCCCE7CBF31497A9B95841BC8E1D6DE9DB2F9E161F1055AEADF57DAD25DB2528706BA9D480E687D2EBA8F6BCFFC501DC7D1938854DC25820CE0864EBAE593FB5864F6965EC5343C92057DC64FE81C6F421FF1DED84E63E3E00981AB3E3DC0BFC9F5D08A9511FBC4E3C75EC53F419ABCF25144C4C9FE929115EFD5B5B9E1FC28B4EBBE03F49D43DD56ACC45590327CFC25B46B17A3C7C035037BB0F77DE8D5E399B32895469E3EF2A38A3786169D9549D1D294F33B059AC4719B4D305F33E452EA900581CB5C21C2542A78374695745DD33D8AC652F5729FBA24113B10132F82C62553EAFA4E21974F8A4B5869063669DB8AE058987D5668E2620C777AAC45745E2B2B9F9D75D52768122C832B714C30EB7BDF69F6D8E1B4F666681C5A207B6EE3EFF6EDB8153A4E0D514FC2B78B352951691C38F607A34332E41209B224B7D880B1CBB41F7B8602F7B310EBDEB7314D93988F05757503A4BD7E327281E574CDCC3FAA33C704411D9385B55DE1BD247EED876F9C6876185CFBF58A36B786FF6DEE18728BF4B1A01873090F7F20E1131CCE48932F74334C04B561B8E82BEF3972C46E8123C1DBF2716DD580496C5A88B9D1DC0BDB83DA9F4BD10B2E929F58CDB34F7ED47FD71E3DF15B1DAC12066B18ADF448686A5BD4B718A9BC5784A4A21A27DCA6B500FF114D675E77494A90908118134D8BB35D4F572121EC7D304DD810357E777326A8990442ECD56E88CB84DD15477A8FE9F916C8261C028D82F02434BE334C09DDADCFE07DFA0799475820C101AFAC547462BA218F1032DC68449E7AB1BF487D77BC9A46172EAED756A82B21668D66A9813E66C958DBA4C554AF29A95E5575E06409BEB8BEFDAA625A864C9776EF4FD3759D4D516452F49E33030AAE561210AED1B78F9DAB293EBE8E758DED61450B4DF68670B8E81994D7A110714C3900DD8BA0C1C1247C05F8668170CA4C2BF16715C259467B11251578895BA5D0F3B3BF57AF6A6A6F616A81D500

pk1=0xDACA351A7D1EBB059F0EB9A9CE674FA908E2389CBF0FF88423579170EAAB62C848E3AAF4C0C9A770D6C0CCA11DE8D7693DEEB58D5FC852F2CE64D493E9268FC29DE8C19D9D72B47B28F69FCDB3F62812A628DFAF586128DEE1F0C44109B0EEFC4D1C01C1108A4BBFE9818ED6E3D4E0AAAB35354BB844B0998E1E011CD7D7FEA89471DF30B4535FE1704552E6FF1483723B19F25952C81FF199FDFC0C556B7F1820C7C32B6E0AF7E6242E3D3F5326C7F3393F823A5C2E9793F8F1371866957EB0A70C57D062443DCE0B0C7139046A27030C39FDC6802F2C8233C8EFB38C69440C74E5A1F8D2A91483197959BCA685FCB660927C743FE5E485D71AE11698D8AF97FDF24777F0F1D19082059829AA13F2EAC442DA0906E266CD9D000E96582C874984793AC9C8735994290282C3154792AEB060D01E9925DE4893EE4942680DC7F89E52B720744479BAFC6ADC7D8792094372704A2AC3E228737AD5EE61A84F2066AF9B08CD67BBF6A41C39A2D2B5E928EDC62F3AB36F4B9C71EB9946EC03180D9FE4B533C712B632A679A0CBF37C3A328E386C1549C161D9683008C8CF0011B5E44C7ED2D6BC04FDEF3ED8DAAA25FFC59C1D4B318D7AF727628225DF92A8B9DE893EEEBFC1F5CB23F7BAA946C2B2C68CB1A676662F50AA2D564054E3B16C1FAD54469EF1C7DA84FA077A811A32A9F2048C75B43260C990B511FFCCD4F8763B2C15BC42A7632CB5AAEB40D94ED7B778F65F02EDB2E536CECA8205513FAB7FD60CCEA4039BF880E2F9B6228437616F167CD12CE841FD6D34AD9E077170DBD624E92D48EE562D194B9B295843E8D783323A3CA744B343D0B4362723307D3A3FD92D5A91AFC652417AF9354DBD435C214F863E87471E2153CAD9AFA8C611C9C70AC1B1028036C921C4197918E5CF39D7FCC997A643BE1957059138366147A73199C1A91C3CA4A0FAEF1BADB47801888DFB284625C03D96CAB0D7939DBFE7B471023A35EBFD887273D5CD40A73EE68E5772EB0FC46B3676A8C87DCB5CDA65D7591DA7087AE57E669FE2C2B0531102ECE2E718DEE53C282A36C09C9D745F3391DF1B87BC3645378A8DA8DE5B47E99C501186E7079D5000B6E7C577FBE79A1DEA03FE2DBCCCF60DCAE52FE6123502802D417295A82B8126F428F19DC6518C3A012F89886DF1D3836B4A55BDF3AF01AF3BC43EE637818403F9FE6B73ADBBDEBE7DE442DC16D85D4E348ACA2B23AD256AD8792858860214C21C4FF6790769AD190269A23BBC84C6693669CE51B8FC29AB06CDACDEDD754E2472D587C17F853771F388D32D3BB8328E15EDA8375E2AA64A2128E78FCB51FA509BE451739983A0686E31D85E78E13BB165DD1222DD198120262395EEA4F14D6A581AC2E821B3E3E6DA43AD83BAD8E5920E37F93D40EC116E5F5230BD6636CEDCE95D4777DE9D11C467325661275B76068A0EBA3232CCC1A55DC5B01E4D65AB92799909758B7504037B68B72941F51F386CED972E01D72B9E13DA4DB4539FA712E547BF9B2559716D70FCAF4E93A2DFEE2AC4222520972B8E0D8DC168ADED27472517E55BAC20D2FCC2766194493D65333002CDD5E215FB9CD1C29A5043B0469D4E4DA88648FBE200D7BD08C771A72624276781D3F05F7B29FFA4FA49D14D45751936886FA09F2F59F141CEC227080A491310152150A7BD4D3774989344F81CD6AA8399F0551B2355E897D8B4B489B2EF488D3DE13E892CC0EDCFBDBBF8680877EBF95A804CD3BD5FC5875E4F17569467D781122D83015F1D1F8112A8C58F44A544BB3202

# pk0
print("-- PK0 -------------------------------------------------------------------------")
n = 0
blocks_out_pk0 = np.zeros(318).astype(int)
blocks_out_pk0_shifted = np.zeros(318).astype(int)

# rearange sk0 to a correct bitorder
s = 0
pk0_cp = pk0 << 8
for b in range(0, BLOCKS):
  s = (s << 32) + flip_bytes_in_block( (pk0_cp >> (10176-(b+1)*BLOCK_SIZE)) & 0xFFFFFFFF)

s = s >> 8

blocks_out_pk0 = extract_words_msb((pk0 << 8))
blocks_out_pk0_shifted = extract_words_msb_without_flip((((2**(5088)-1 & (s >> 5)) << 5075) + (s >> (5088+5))) << 13)

print("-- NONE SHIFTED --------------------------------------")
print_ram_content(blocks_out_pk0, "FAST")
print("-- SHIFTED -------------------------------------------")
print_ram_content(blocks_out_pk0_shifted, "FAST")
  
  

# pk1
print("-- PK1 -------------------------------------------------------------------------")
n = 0
blocks_out_pk1 = np.zeros(318).astype(int)
blocks_out_pk1_shifted = np.zeros(318).astype(int)

# rearange sk1 to a correct bitorder
s = 0
pk1_cp = pk1 << 8
for b in range(0, BLOCKS):
  s = (s << 32) + flip_bytes_in_block( (pk1_cp >> (10176-(b+1)*BLOCK_SIZE)) & 0xFFFFFFFF)

s = s >> 8

blocks_out_pk1 = extract_words_msb((pk1 << 8))
blocks_out_pk1_shifted = extract_words_msb_without_flip((((2**(5088)-1 & (s >> 5)) << 5075) + (s >> (5088+5))) << 13)

print("-- NONE SHIFTED --------------------------------------")
print_ram_content(blocks_out_pk1, "FAST")
print("-- SHIFTED -------------------------------------------")
print_ram_content(blocks_out_pk1_shifted, "FAST")


print("----------------------------------------------------------------")
print("Cryptogram:")


c0=0x93F5366397957BBCBAE45C09818915F092DC0FEFFB7421915D84B376F1EED36B1718A7E2D0B2E4DA937E29B0B693BE248F567761D73BDA342841AFE55AB94FD7C210EBE125E29B2C8EC2D5AD844B05AFF5F141F5007DBBBE41E04D913234B0D99A370FF9B1938102C93D1E36F30636A33140DF06D2D8CC60ED89C446DCC76221C021045156D50A1836C530A2FCE767D62A650871731DF4D0EA0FCB175A09CA9CD0A44DFC4F4143181862D6146F5EB43C7E70C6C3E6626C6271506C27F2B56A94F4633571D5998A3189C6215E1BFA98C931DBEBE47B2589A13BC1C10153434202A235CF94FC8D256580CAEB200C7D99E0DFE4B65E5CFB8FCF5B0B13E59039A1CE7FB3C916D0B41E6CAF6568E85DA7F4AD0A75F6848CDD2CF7912C057731E359AA4075D2DAFEE5F6B68B76C22DD994C89B35F53E5EC17F2623A30F79AFEEA5B3D6CF378D7A1C358F5AD1E9BC26FCD3BEDCE6F6AF992D60C88379AFA5D38DE5A565983522E936B382F138268425C2F07FE5064CD0990FDD372D8DECD1EB4972CABEA90E019DED68FE0EFDFFCDC4BD763654B9ADC72E3F776C7AF7723D3FFC3B70AC5A6C3E53BD69C8B31881DE22157984646F5F191F73A30324F687C1724FDBBA149B5CB12F1FD6D626B13FE6781501B9A209BF7226B8EA6DC7B43784DE079AA7849925D6F09DD1F0ABF3537B2DC05304D5E65BDE22A75EB8CF9DD21F5A44DCCF3F02AB14BE42E35E110CE6DF2EF2D68D30A87DB3BA8235E70B458F41F65ABDBC463D46C007624FB8E7DE0C8CDB6E12713421AA52B990E1811AAFA9B8922FB2D85195B9EFD0DC5F6A3F0677B970698CFB3C0E89756AA8FABA7647DB1EFAEE69516E0D06159BA4068DB255287C3253AC4B9E96CCE1ACA185F325E48410B15A83104334E5C00DC1305B6B39B602F5077DDE10EB95E6F3BAB293748D828B2C1953419E8C77FF6087659A1ED74633E39E9938A4C5C7649B7FD7F04E1DD3F30DEE24E20653EE0C8D9B64F1E3A368B3B425CAD322751C0ADD601618AFBB7EEB2F40F496E4803A895F747A33E2C2980932812B1B012B5178EB928E79FA21AC04E12AC9F36F619CDB45FC6DECAB669FA3B6145F3E0CEEDC7921B824A89D84741C1F020F5E2E1AA4A091D30B79B2C067F2FFF98172D4B756EAAB3CB63B1067297D7744D188B19E4874597B14BD13A61508E3E33B4E1797535C52651C6F2BA9A8AF536E8A3A4675EC52C616E035EE37C355553E19C8CDDEBA74C125C97F63898EA5833AA5B8D353CE000A9B7C916FA2B0D39297E898AD440C0A9F0FC1F7BB3F0E8000D29A14CA5EBAD1DF05B60A12AB83C19FC2ADA8396CF3BAF8E334F7A67C160B8BC471C2F7CE8AC1FD7ABDDBBD7E7E46EF605F094F4AAFDCAFD51789F191976CB7DC0CF95C66D66274D758CE8146AE04891396B1B6051DEE10A6654BAD45091FE305B93122EB7A2DA254D388E46120E271FA3B25C4DD977F0336459F4E77BB49B5D80F2208E9BA6A62D4F6EC4E3E279F4B8198DC6C2257BDE66242E63E7D782535543AF2438F5A4B681499A943DB38B4CF84C641294819A72E3E1D5E1B3EB1E204F8EFC4C46FFB4BBFEB4D153620A824038B6DC59E4CA5CD0B1DEF135CD10B69FBE745A33ADE3D4EBA84F4299DC7E9EAB789018265A1C5D6A806187A8FF3CEE8EFECB269C8828D7455F0F257E8307545F7C1A1E090EC5786AC4FB7B8B79EDF449F43E4C867F8D755305FB97296A780CAFA8CC963A5AFD7BF126AC81CDAF1FF0F81DF94372A8148651EFF6EC87F3A3FF5CB8DB2F5BE1047717F05AB0100

c1=0xDA9A8FCE9C676031328BB57CFCD7781F2E25CD9605F88F881C4C99D8B5D061503CDB9001F5F5B334C553FC3397C68F58F72C8CD9BF53A6B74D13FFCF7B2A6A3518407AF28E8E5755B97066E9CE73C56DA2202F22B6768880E7FF50D20E13A9FF07D1932C989FDEA6226C4334B8DFDC781EEE058C19B0333B1A2E9993B54ECA233846EFBAD11A934016B1FD443DEF83D8E2E5003EF8DA15EE1D787BC0F6CB0A17717A1A4045B3624E2F9EE713590D1216F9372E801DF9AF1A27690442398E96B6FADBFCC535918F7C93CE190A950446183B04BEEDD4BFF8C121E4C1850E10061F0726BE49CA6C4D116EB99FDAC7F9AB54493F0E7D7496EBD9A6ECC7D3719F30A370242556EAF9FAB8798AA0A5C1EE4154F60246DFB643D9B8B2C701D4B234A4E4B36FA34FF84F4BA86ACBB1A17A32551B98F1FD68F372E91CEACFA006B755697186B91F322EF15D42E9CC7FF7A3CA60A88B9114BD5F0710A10B6BA5BCE032AEE487F43679A5D68345B561ECE82CA7E2628A57979186E5C45C626F42E944CD56C43EF47713100FCFF78983B72E75C4FD6353C7F751AFAD9F15FFC6AA5CFE1FFD4FBE181D8ED92908C7201A8F8322FA43DCDE9AA9A7170A00F2AD38CF6D701A5346207FDADC6AF29FF2F8C288C310CE09D39861EE3B39464457A4B57BB43559CD4CB5BF78190F8B9D4104F997E3B2612DCAB0E3F2A7913730DD32E6F23344D694A2AAB0EE183EC3094AA7BCC163A5DCAA7D895EFA4AE508F1FDD7B4EDC611F93254F1AACC31AD32CFADF89E5BBC03B594746363B1B965B4E656F2CEA0A5A9453AA1432190DEAA6A0D4EFD4447A305DD38A276747FCD6BE4163E24755E19612780A547BCD3542409292554DCBEA480AFBCB3D14AF4B47102D597F8A9A3CDEE11AF08F629D775EFE4D9C3C759E192E8AEDF4FF4166B32A664B406CE07EA212AF2E6DA8FB33DD475AF536E0B85F8A25C1B671ABF2B9D4C704FF6A67005064E722A163A8EFC840FDE0EC7778F2AA6F30439A6CF9BDA5DBE2CB14C29BF1C3D8D708A1BDE12387860296677BCD0318749ECD3CFF666DD58646435B0A736BBC3DACE5E03FEEBFB49B2842A7D0BCA2C3A1E590364FD1AE73DCDD9FF0D85A08236E044781448973B8F46294CB0A04407A6E12473A317811182ED1D519D8212FD20EF68D027B58027ED58D1B0F82CC83D3E5D832024B688C5AACB6372C74D31A05C08BA9F34431CCC6FC34B4C46F2FC8B8DEEF28ACD478791991639F89BD2F6E6B868D0A3260AEE1686EB7D1DF05F4CAB8A0D15D76FDF55C3C74A653D4F0D6126BC49CAFF6763013A06D6EAC3AA20553C6F2B01138CC50379F3B00446B4B7431113A60EBF5E3525B45E2582E241E5B07FB9056D22ACB7F570422B2A54E0AAFF4AE6E55C33948EBD703376B257EEB07D2149E7B9185E06A9A9668771B91F089C24B151F9E5055A72F04F5B1D514BFBCECC1A1939E8878208BA247E7A85890458A2E8988A7DC34A9A5337222EEDAFBBD7F7218696F67C741C645FA87C0362AEE545252E52FA2EB90DB5A44C6A196288F48BACBEE4A3BEE3D2005971F96F7D7E4BBD370133D12CA717F87998F5E87C0EE8C1747B2B2038C0E8879537CAFFA98CE18A869844E0915A19A9FCCBABDF70FC04D7055AEC2F8ECC7CB956263E2D53AB2B42F7FFE0ACE78B42E7FCFD41687A0C60C9442C9BD493627853B52B62783646495DB51C06869790E2729870FBF09BADC04FA4AF627B09E3D6F9D335BAE913585E3E3994AC12098A5F0A7B7A2FCC37B6B8B453E8AA09A17A34DDDDB455CE0500


# ct0
n = 0
blocks_out_ct0 = np.zeros(318).astype(int)
intermediate = 0

print("C0")
print("==========")
for b in range(0, BLOCKS):
  current_block = flip_bytes_in_block( (c0 >> (10176-(b+1)*BLOCK_SIZE)) & 0xFFFFFFFF )
  temp = (intermediate << 19) + (current_block >> 13)
  intermediate = current_block & (2**13-1)
  current_block = temp
  current_block_hex = hex(current_block).split('x')[-1].zfill(8)
  if PRINT_C == 1:
    print(current_block_hex)




# ct1
n = 0
blocks_out_ct1 = np.zeros(318).astype(int)
intermediate = 0

print("C1")
print("==========")
for b in range(0, BLOCKS):
  current_block = flip_bytes_in_block( (c1 >> (10176-(b+1)*BLOCK_SIZE)) & 0xFFFFFFFF )
  temp = (intermediate << 19) + (current_block >> 13)
  intermediate = current_block & (2**13-1)
  current_block = temp
  current_block_hex = hex(current_block).split('x')[-1].zfill(8)
  if PRINT_C == 1:
    print(current_block_hex)
  
  
  
  
##############################################################################
# SECRET KEY
##############################################################################

sk0=0x0000000000000000000000000001000000000000000000000000000000000000000000040000000000000000000000000000000000800000000000000000000000000000000000008000000000000000000000008100000000000400000000000000000000002000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000010400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000400000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000002000000000000000000000080000002000000000000000000040000000000000000000000000000000000000000000000000000000100000000000000200000000000000000400000000000000080000000000000000000000200002400000000000000000000000000200000200000000000000000000000000000000000000000000000000000000000000000000000000000000020020000000000000000000000000000000020000000000000004000000000000000000000000000000000800000001000000000002000000000000000000000000000000000000000000000000000000000000000000000000800000000000000400000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000200000000000000000000000000000000000000000000000000001000000000000080000000800000000040001000000000100000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000010000000000000400000000000000000000000000008084100000020000000000000000000002000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010040000000000000000040000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000008000000000000080000000001000100000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000



sk1=0x000000000000000200000000000000000000000000000090000000000000000010000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000101000008000000000000000000000000000000000000000000000000000000000000000000000000000000040000000200000080000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000080000000000000000000000000000000000000200000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000400000000000000000000000000000000000000040000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000010000000000000000000000000008000000000000000000000000000000000001000000000000004000800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000010000000000000000000000000000000000000000040000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000200000000002000001000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000200000040000000002000000000000000000000000010000000001000000000000000000000000000000000000000000000040000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000800020000000000000000000000000000000000000020000000000000000000000000000080000000000000000000400000000000080000100000000000000000000000000000000010000000000000000000000000000000000000000800000000000200000000000000000000000000000000000000000000000000000800000000000000044000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000001000000000020000000000100000000000000000000000000000000100000000000000000000002000000000000000100000010000000000000200000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200080000000000000000000000000000000000000000000004000000000000000000000000000000 # added 8 extra bits


# sk0
print("-- SK0 -------------------------------------------------------------------------")
n = 0
blocks_out_sk0 = np.zeros(318).astype(int)
blocks_out_sk0_shifted = np.zeros(318).astype(int)

# rearange sk0 to a correct bitorder
s = 0
sk0_cp = sk0 << 8
for b in range(0, BLOCKS):
  s = (s << 32) + flip_bytes_in_block( (sk0_cp >> (10176-(b+1)*BLOCK_SIZE)) & 0xFFFFFFFF)

s = s >> 8

blocks_out_sk0 = extract_words_msb((sk0 << 8))
blocks_out_sk0_shifted = extract_words_msb_without_flip((((2**(5088)-1 & (s >> 5)) << 5075) + (s >> (5088+5))) << 13)

print("-- NONE SHIFTED --------------------------------------")
print_ram_content(blocks_out_sk0, "FAST")
print("-- SHIFTED -------------------------------------------")
print_ram_content(blocks_out_sk0_shifted, "FAST")


n=0
blocks_out_sk = np.zeros(W).astype(int)
intermediate = 0

#sk0
for b in range(0, BLOCKS):
  current_block = flip_bytes_in_block( (sk0 >> (10176-(b+1)*BLOCK_SIZE)) & 0xFFFFFFFF)
  temp = (intermediate << 19) + (current_block >> 13)
  intermediate = current_block & (2**13-1)
  current_block = temp
  if current_block != 0:
    address = BLOCKS-1-b
    for i in range(0, 32):
      if (current_block & (1 << i)) != 0:
        bit = np.log((1 << i))/np.log(2)
        rand_out = (address << 5) + bit.astype(int)
        blocks_out_sk[n] = rand_out
        n = n + 1

# sk1
intermediate = 0
for b in range(0, BLOCKS):
  current_block = flip_bytes_in_block( (sk1 >> (10176-(b+1)*BLOCK_SIZE)) & 0xFFFFFFFF)
  temp = (intermediate << 19) + (current_block >> 13)
  intermediate = current_block & (2**13-1)
  current_block = temp
  if current_block != 0:
    address = BLOCKS-1-b
    for i in range(0, 32):
      if (current_block & (1 << i)) != 0:
        bit = np.log((1 << i))/np.log(2)
        rand_out = (1 << 14) + (address << 5) + bit.astype(int)
        blocks_out_sk[n] = rand_out
        n = n + 1    

with open('sk_flip.txt', 'a') as f:
  for item in blocks_out_sk:
    item_bin = bin(item).split('b')[-1].zfill(15)
    for i in range(0,15):
      f.write("%s" % item_bin[i])
    f.write("\n")
f.close()




g=0x7C02300767A1B59361246A7C5EDDD2EC5906BEB70B6D1590B4C0FBFAB6D488FD701BA939B8B9DB8F16AA60D09742A14735F0454C46047859315FF22B816A8FB3201D8A3EBBAA7D06B9354EE635899BE8ADBEF382A0013FD6C1F90382F817364E0085AFFF201A84E3BC1FA05BB40F0CD058A798F63BF415420891B63350584DB4C887A04D2CAD6A0DD5BA72A7FA11F6A76444918868C5C7C57C49BF800F617E05882004266160F3733E1E3E91544288AF98663BBF704303E922EE92421009BFAD4902FF1638EF5880E4D1D6C7AAF9AC602BAC508C274683B099C9ECF09282FDD6729575A49BB633DD8650B93320B19F62D01771863D9D6FBB736F75841C5573E2CDD999B9579F25C9BD1AF13EAD207DC74236412A5B000590FF9888E951473D2DC0FB5FA755204C0C1064EA8E2443932D931A8BF4F98A28508B00D7541BC163299B0F0F6F2CA4F788E94D2799CCFF2A2DD0925A43C32A92C48A83B7E20D3E9486882259F1CA035B8E1CC720AAA96C21EF4B46DDEDEF02A3986C69F64E11B986189C5EB50EF2C50B4689105B22C7F6B8E3C3B5AD68D4E8A7838054F201BA564B5FD63D62218AC7F7BCD146FC0EF12F527B2B0B756A94F266F790E34F933012A86A9DC1F6782A46508025E00E23B408DB58488C9C0D479F9D56A459F68C19C3100AE8A0B0DDAB06CBAF94FDD6CAC33E9C3967F8EF68F7280728060E184EA730B104B514D146F430F24B212B417B1D0E7CFFE0C987CC59A0509A985DADC7572AF8499238E4FC2DFE71DE0D6D312E51A5FC892A40AB434A9C066B9B6EBC76D8ED2C49E7C32F30E3243ED59695AFFA3B7D1E984DA21BD9F02D855733500A56D329C663188168E226B3FA5D48E19A9052E1DD787A5E37BC067E3B0E52BF9AC652276BF18464535A83E8D07DC4EDB594168071DBFAC8EEF70B19C209059B529BDF4AAFC06B65D74B625E355BBD7E47544A9909894DE7178CEA27E8E89F9D0A656FCFEB0EB09DF06791E21985DAF9EFAF15FB988B21AE03F1DFF7C5955D9FAE0FA661BD18ECDE53E870014D2AE788874266D3DA0A7B00C5016C15AF8413F2DE0A05B2A4419F186804A73705B4F02976516D5F8A861FAB4B1BFECB503D5C7B1F53BF566E84D1682AF70F8AAA5CE2748E3F6AF0D4D17AA9B779E1589DD1B4793B610B12E5BF12C3E69B4CDC5C9B6D7D325D0A6393CB95C7851DC790B92979FBDEAAC6B8F342108C1AE0585AB6949BF67FD53F4EF42B92D8112DBDFEF416499292F73BB243A228C8D7F6C5B2A6CAD778A5FEAB201881763F66BB135AB11AFCFEAF140D4EDE18E17E89575CB682CCD09DC9800403536C466C45D164057327E4AB9BD9273E3EB7EB5713A8ED3D0950C0E44776D9F40EA860E7AAD1D8542CD4B7AA278037EAFBC7619209AF843285423C61DDE8FAA08D08E6D5A57D80644B9360665E55D266408137711C0E1CDA21DB6FAED423B3906A3E7B67DABF1EDD3699BF3C3E91B149F3C002E7BF510F0AB7327EDB5970D74C6B770625EBE041CAED91B7955EF5BCD6A4C73E803F540E1C946F000FB71879B63D2F023D702FA156A676033C6C863DF576D7F7D4044571627C05195810CE75DEDAB09CC52C25BF7882CD4CECC60235393A1EF1AE33BE329908AD1D0EC242283AB21ACE9703696EB9A519652CD12A370F9CDBCBC7B6A0FE82D8AA97FADF31BB9D774027B11B4F0087782184165BDEB1BA61592FAE83B6C407C85DCE5559BC2DA5728307F481730B77330B2EB12F9FE9FC67381530B7A8C199ADA4410C5CEA0809B064371CC76BE14C0000


blocks_out_g = np.zeros(BLOCKS).astype(int)

for b in range(0, BLOCKS):
  current_block = flip_bytes_in_block( (g >> (10176-(b+1)*BLOCK_SIZE)) & 0xFFFFFFFF )
  current_block_flipped = int('{:032b}'.format(current_block, width=32)[::-1], 2)
  blocks_out_g[b] = current_block_flipped

with open('g_flip.txt', 'a') as f:
  for item in blocks_out_g:
    item_hex = hex(item).split('x')[-1].zfill(8)
    f.write("%s%s%s%s%s%s%s%s\n" % (item_hex[0], item_hex[1], item_hex[2], item_hex[3], item_hex[4], item_hex[5], item_hex[6], item_hex[7]))
f.close()
